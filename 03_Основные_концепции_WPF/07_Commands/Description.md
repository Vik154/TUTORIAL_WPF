### Концепция команд - *представляет собой механизм, упрощающий связывание задач, запросов и действий.* 

*Информация MSDN: https://learn.microsoft.com/ru-ru/dotnet/desktop/wpf/advanced/commanding-overview?view=netframeworkdesktop-4.8* <br>

Команды WPF представляют собой подобные событиям сущности, которые независимы от конкретного элемента управления и во многих отношениях могут успешно применяться к многочисленным (и внешне несвязанным) типам элементов управления. Команды позволяют определять действия в одном месте, а затем ссылаться на них из всех элементов управления, таких как пункты меню, кнопки панели инструментов и т.п. <br>

Прямую реакцию приложения на определенные действия пользователя обычно называют задачами, а сами запросы на действия - командами. Команды используются для упрощения связывания задач, запросов и действий. Команды, как и события, в WPF являются маршрутизованными (Routed - направленный). Но здесь есть отличие: события могут туннелировать и всплывать, а команды только всплывают (команды бывают только пузырьковые, восходящие, всплывающие). На самом деле всплывают не сами команды, а генерируемые ими маршрутизованные события. <br>

WPF поддерживает команды Сору (Копировать), Paste (Вставить) и Cut (Вырезать), которые могут применяться к широкому разнообразию элементов пользовательского интерфейса (пунктам меню, кнопкам панели инструментов, специальным кнопкам) и могут использоваться в качестве альтернативы событиям, в результате получается более компактный и гибкий код. <br>

Модель перенаправляемых команд WPF можно разбить на четыре основных понятия: <br>
> *команда, источник команды, цель команды, привязка команды.* <br>

_Команда_ — это выполняемое действие. <br>
_Источник команды_ — это объект, который вызывает команду. <br>
_Цель команды_ — это объект, для которого выполняется команда.<br>
_Привязка команды_ — это объект, сопоставляющий логику команды с командой. <br>

Команды в WPF создаются путем реализации интерфейса System.Window.Input.ICommand: <br>
*MSDN: https://learn.microsoft.com/ru-ru/dotnet/api/system.windows.input.icommand?view=net-7.0*
~~~C#
public interface ICommand {
  event EventHandler CanExecuteChanged;  // вызывается при изменении состояния команды 
  bool CanExecute(object parameter);     // возвращает true, если команда включена и доступна для использования, иначе false
  void Execute(object parameter);        // предназначен для хранения логики команды
}
~~~

Также существует стандартная реализация ICommand в виде класса System.Windows.Input.RoutedCommand, который является базовым для всех встроенных команд и если потребуется создать свой класс команды, можно реализовать интерфейс ICommand или унаследовать свой класс от RoutedCommand. <br>
*MSDN: https://learn.microsoft.com/ru-ru/dotnet/api/system.windows.input.routedcommand?view=windowsdesktop-7.0* <br>
~~~C#
// Реализующий класс RoutedCommand расширяет сигнатуру объявленных в ICommand методов до второго аргумента target
public bool CanExecute(object parameter, IInputElement target);  // parameter содержит сведения о команде 
public void Execute(object parameter, IInputElement target);     // target - сведения о целевом элементе команды.
~~~

Одна из ключевых концепций, лежащих в основе модели команд в WPF, состоит в том, что класс RoutedCommand не содержит никакой прикладной логики. Он просто представляет команду. Это означает, что один объект RoutedCommand обладает теми же возможностями, что и другой.

Класс RoutedCommand добавляет дополнительную инфраструктуру для туннелирования и пузырькового распространения событий. Если интерфейс ICommand инкапсулирует идею команды — действие, которое может инициироваться и быть или не быть доступным, то класс RoutedCommand изменяет команду так, чтобы она могла подобно пузырьку подниматься вверх по иерархии элементов WPF до подходящего обработчика событий.

Для поддержки маршрутизируемых событий класс RoutedCommand реализует интерфейс ICommand как приватный и затем добавляет немного отличающиеся версии его методов. Наиболее заметным изменением является то, что методы Execute() и CanExecute() теперь принимают дополнительный параметр, в которых аргумент **target** представляет собой целевой элемент, в котором начинается обработка события. Это событие начинает обрабатываться в целевом элементе и затем поднимается вверх до находящихся на более высоком уровне контейнеров до тех пор, пока приложение не использует его для выполнения подходящей задачи. (Для обработки события Executed элементу необходима помощь еще одного класса, а именно — CommandBinding.)

WPF уже обладает большим набором встроенных команд. Все они представляют объекты класса RoutedUICommand, который является производным от RoutedCommand. <br>
Объект RoutedUICommand не имеет никакой жестко закодированной функциональности. Он просто представляет команду. Для активизации этой команды необходим **источник команды** (или специальный код), а для ответа на нее — **привязка команды**, которая переадресует ее выполнение обычному обработчику событий.

**Источники команд** <br>
Источником команды является элемент, который вызывает команду. Чтобы стать источником команды, элементу необходимо реализовать интерфейс ICommandSource:
~~~C#
public interface ICommandSource {
    ICommand Command {get;}            // представляет выполняемую команду
    object CommandParameter {get;}     // предоставляет любые данные, которые должны отправляться вместе с командой
    IInputElement CommandTarget {get;} // идентифицирует элемент, на котором должна выполняться команда
}
~~~
Чтобы связать элемент с командой, используется следующий синтаксис:
~~~XAML
<!-- Кнопка связывается с командой ApplicationCommands.New посредством свойства Command -->
<Button Command="ApplicationCommands.New" />

<!-- Также допустимо сокращение название команды: -->
<Button Command="New" />
~~~
~~~C#
// Свзывание можно производить и в коде C#:
button_name.Command = ApplicationCommands.New;
~~~

**Привязки команд** <br>
После присоединения команды к источнику команды происходит нечто интересное: источник команды автоматически отключается. <br>

Например, после создания кнопки New (Создать), она появляется как затененная и недоступная для щелчка, как будто ее свойство IsEnabled установлено в false:

<img align="left" width="220" height="90" src="img/Command2.png" alt="Пример работы данного кода"/>

~~~XAML
<Window ...VS>
    <Button Command="New" Content="New" Width="120" Height="30"/>
</Window> 
~~~

Это объясняется тем, что кнопка запрашивает состояние команды, а поскольку команда не имеет присоединенной привязки, предполагается, что она отключена. Чтобы изменить такое положение дел, для команды понадобится создать привязку, которая указывает три следующие вещи: <br>
* Действие, которое должно выполняться при инициировании команды.
* Способ, который должен использоваться для определения того, может ли команда быть выполнена.
* Область, на которую распространяется действие команды.

Все команды, в том числе и встроенные, не содержат конкретного кода по их выполнению. Это просто специальные объекты, которые представляют некоторую задачу. Чтобы связать эти команды с реальным кодом, который бы выполнял некоторые действия, нужно использовать привязку команд.

Привязка команд представляет объект CommandBinding. Его событие Executed прикрепляет обработчик, который будет выполняться при вызове команды. А свойство Command уставливает саму команду, к которой относится обработчик.

~~~C#
CommandBinding commandBinding = new CommandBinding();  // Создание объекта привязки команды CommandBinding
commandBinding.Command = ApplicationCommands.Help;     // установка команды
commandBinding.Executed += CommandBinding_Executed;    // метод выполняющийся при вызове команды
MyButton.CommandBindings.Add(commandBinding);          // добавление привязки к коллекции привязок элемента Button
~~~

Любой элемент управления WPF наследует от класса System.Windows.UIElement, который имеет свойство-коллекцию CommandBindings типа CommandBindingCollection, предназначенную для того, чтобы можно было сделать этот элемент прослушивающим команды. В эту коллекцию помещаются специальные объекты привязки CommandBinding, у которых имеется свойство Command и событие Executed. Мы создаем объекты CommandBinding, присоединяем к их свойству Command нужные объекты команд, а к событию Executed - соответствующие обработчики. Затем эти настроенные объекты добавляем в коллекцию CommandBindings элемента. Так элемент становится прослушивающим.

Как уже говорилось, когда источник команды возбуждает присоединенный к нему объект команды, тот последовательно выполняет методы CanExecute() и Execute() интерфейса ICommand. Эти методы генерируют командные события, которые движутся по дереву элементов, проверяя их коллекции CommandBindings с целью обнаружить объект CommandBinding, соответствующий возбужденной команде. Как только такой объект привязки будет обнаружен в прослушивающем команду элементе, немедленно выполнится подписанный на событие Executed обработчик.

В качестве прослушивающего можно сделать любой элемент логического дерева. Но для получения наибольшей гибкости привязки команд рекомендуется добавлять в корневой элемент - окно (или Page ).

<img align="left" width="300" height="190" src="img/Command1.png" alt="Пример работы данного кода"/>

~~~XAML
<Window ...VS>
    <StackPanel HorizontalAlignment="Left">
        <Button x:Name="btn" Content="Help" Width="150"
                Command="ApplicationCommands.Help">
        </Button>
        <TextBlock x:Name="txtInfo" Margin="5" MinHeight="200"/>
    </StackPanel>
</Window>
~~~

~~~C#
using System.Windows;
using System.Windows.Input;

namespace _07_Commands;

public partial class MainWindow : Window {
    public MainWindow() {
        InitializeComponent();

        CommandBinding commandBinding = new CommandBinding(ApplicationCommands.Help);
        commandBinding.Executed += new ExecutedRoutedEventHandler(MyLogical);

        btn.CommandBindings.Add(commandBinding);
    }

    // Обработчик для команды
    private void MyLogical(object sender, ExecutedRoutedEventArgs e) {
        txtInfo.Text += $"Вызвана команда HELP\nИсточник: {e.Source}\n";
    }
}
~~~



