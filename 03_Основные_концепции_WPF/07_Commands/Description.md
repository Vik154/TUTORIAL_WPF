### Концепция команд - *представляет собой механизм, упрощающий связывание задач, запросов и действий.* 

*Информация MSDN: https://learn.microsoft.com/ru-ru/dotnet/desktop/wpf/advanced/commanding-overview?view=netframeworkdesktop-4.8* <br>

Команды WPF представляют собой подобные событиям сущности, которые независимы от конкретного элемента управления и во многих отношениях могут успешно применяться к многочисленным (и внешне несвязанным) типам элементов управления. Команды позволяют определять действия в одном месте, а затем ссылаться на них из всех элементов управления, таких как пункты меню, кнопки панели инструментов и т.п. <br>

Прямую реакцию приложения на определенные действия пользователя обычно называют задачами, а сами запросы на действия - командами. Команды используются для упрощения связывания задач, запросов и действий. Команды, как и события, в WPF являются маршрутизованными (Routed - направленный). Но здесь есть отличие: события могут туннелировать и всплывать, а команды только всплывают (команды бывают только пузырьковые, восходящие, всплывающие). На самом деле всплывают не сами команды, а генерируемые ими маршрутизованные события. <br>

WPF поддерживает команды Сору (Копировать), Paste (Вставить) и Cut (Вырезать), которые могут применяться к широкому разнообразию элементов пользовательского интерфейса (пунктам меню, кнопкам панели инструментов, специальным кнопкам) и могут использоваться в качестве альтернативы событиям, в результате получается более компактный и гибкий код. <br>

Модель перенаправляемых команд WPF можно разбить на четыре основных понятия: <br>
> *команда, источник команды, цель команды, привязка команды.* <br>

_Команда_ — это выполняемое действие. <br>
_Источник команды_ — это объект, который вызывает команду. <br>
_Цель команды_ — это объект, для которого выполняется команда.<br>
_Привязка команды_ — это объект, сопоставляющий логику команды с командой. <br>

Команды в WPF создаются путем реализации интерфейса System.Window.Input.ICommand: <br>
*MSDN: https://learn.microsoft.com/ru-ru/dotnet/api/system.windows.input.icommand?view=net-7.0*
~~~C#
public interface ICommand {
  event EventHandler CanExecuteChanged;  // вызывается при изменении состояния команды 
  bool CanExecute(object parameter);     // возвращает true, если команда включена и доступна для использования, иначе false
  void Execute(object parameter);        // предназначен для хранения логики команды
}
~~~

Также существует стандартная реализация ICommand в виде класса System.Windows.Input.RoutedCommand, который является базовым для всех встроенных команд и если потребуется создать свой класс команды, можно реализовать интерфейс ICommand или унаследовать свой класс от RoutedCommand. <br>
*MSDN: https://learn.microsoft.com/ru-ru/dotnet/api/system.windows.input.routedcommand?view=windowsdesktop-7.0* <br>
~~~C#
// Реализующий класс RoutedCommand расширяет сигнатуру объявленных в ICommand методов до второго аргумента target
public bool CanExecute(object parameter, IInputElement target);  // parameter содержит сведения о команде 
public void Execute(object parameter, IInputElement target);     // target - сведения о целевом элементе команды.
~~~

Одна из ключевых концепций, лежащих в основе модели команд в WPF, состоит в том, что класс RoutedCommand не содержит никакой прикладной логики. Он просто представляет команду. Это означает, что один объект RoutedCommand обладает теми же возможностями, что и другой.

Класс RoutedCommand добавляет дополнительную инфраструктуру для туннелирования и пузырькового распространения событий. Если интерфейс ICommand инкапсулирует идею команды — действие, которое может инициироваться и быть или не быть доступным, то класс RoutedCommand изменяет команду так, чтобы она могла подобно пузырьку подниматься вверх по иерархии элементов WPF до подходящего обработчика событий.

Для поддержки маршрутизируемых событий класс RoutedCommand реализует интерфейс ICommand как приватный и затем добавляет немного отличающиеся версии его методов. Наиболее заметным изменением является то, что методы Execute() и CanExecute() теперь принимают дополнительный параметр, в которых аргумент **target** представляет собой целевой элемент, в котором начинается обработка события. Это событие начинает обрабатываться в целевом элементе и затем поднимается вверх до находящихся на более высоком уровне контейнеров до тех пор, пока приложение не использует его для выполнения подходящей задачи. (Для обработки события Executed элементу необходима помощь еще одного класса, а именно — CommandBinding.)

Помимо этого в классе RoutedCommand теперь еще предлагаются три новых свойства: Name (имя команды), OwnerType (класс, членом которого является команда) и InputGestures (коллекция любых нажатий клавиш, клавиатурных комбинаций или действий мыши, которые также могут использоваться для вызова команды).

<img align="center" width="1200" src="img/Command1.png" alt="Пример работы данного кода"/>

~~~XAML
<Window ...VS>
    <StackPanel HorizontalAlignment="Left">
        <Button x:Name="btn" Content="Help" Width="150"
                Command="ApplicationCommands.Help">
        </Button>
        <TextBlock x:Name="txtInfo" Margin="5" MinHeight="200"/>
    </StackPanel>
</Window>
~~~

~~~C#
using System.Windows;
using System.Windows.Input;

namespace _07_Commands;

public partial class MainWindow : Window {
    public MainWindow() {
        InitializeComponent();

        CommandBinding commandBinding = new CommandBinding(ApplicationCommands.Help);
        commandBinding.Executed += new ExecutedRoutedEventHandler(MyLogical);

        btn.CommandBindings.Add(commandBinding);
    }

    // Обработчик для команды
    private void MyLogical(object sender, ExecutedRoutedEventArgs e) {
        txtInfo.Text += $"Вызвана команда HELP\nИсточник: {e.Source}\n";
    }
}
~~~








При возбуждении элемента-источника, к которому прикреплена команда (объект RoutedCommand), вызывается метод CanExecute(). Этот метод возбуждает туннельное событие PreviewCanExecute, которое начинает спускаться от корня визуального дерева элементов к источнику команды и собирает информацию с целевых элементов о возможности выполнения команды. Получив результаты опроса от события PreviewCanExecute метод CanExecute() возбуждает парное восходящее событие CanExecute с заданием оповестить целевые элементы принять состояние в зависимости от полученной информации от события PreviewCanExecute, а сам возвращает флаг возможности или невозможности выполнения команды.

Если метод CanExecute() вернул значение true, значит исполнение команды возможно и следом вызывается метод Execute(), который последовательно возбуждает парные события PreviewExecuted и Executed как указание выполнить команду во всех целевых элементах прикрепленными к ним обработчиками. Событие отмены выполнения CanExecuteChanged вызывается, если диспетчер команд, в котором централизованно выполняются командные операции, обнаруживает в источнике команды изменения, которые могут сделать недействительной команду, вызванную, но еще не выполненную в целевом элементе.

Библиотечные классы команд
Библиотека .NET Framework имеет множество готовых команд, наиболее часто встречающихся в приложениях. Команды представлены в пространствах имен System.Windows. Input и System.Windows. Documents следующими статическими классами:

ApplicationCommands
ComponentCommands
MediaCommands
NavigationCommands
EditingCommands
В каждом из приведенных классов команда объявлена как статическое свойство только для чтения типа RoutedUICommand (или RoutedCommand ), следовательно при использовании команды создавать экземпляр класса команды не нужно. Команды имеют имена, ассоциируемые с выполняемой задачей, например, Cut, Copy, New и т.д.





